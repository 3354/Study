# 学习小结

## 1. Shader入门
- Draw Call,即CPU向GPU发起的一次渲染请求，GPU根据渲染状态和所有输入的顶点数据进行计算，最终输出像素（渲染状态指的是网格被渲染时使用的着色器、光源属性、材质等）。

## 2.网络游戏实战
- 多路复用Select，可同时检测多个Socket状态，如果有一个（或多个）Socket可读（或可写，或发生错误），那就返回这些可读的Socket(将不可读的移除)，如果没有可读的，那就阻塞

## 3.Unity3D 游戏开发
- 2018版本提供了保存属性的功能，每个组件都可以保存，可以将参数保存到文件中，或者从文件中选取来设置新组件的参数（在齿轮小图标的左边）。
- Package Manager，Unity提供的内置插件，可以根据选择进行下载，插件的代码及资源并不放在Asset目录下。

## 4.关于tcp
- TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。 即面向流的通信是**无消息保护边界的。**
- UDP（user datagram protocol，用户数据报协议）是无连接的，面向消息的，提供高效率服务。不会使用块的合并优化算法，, 由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。 即面向消息的通信是**有消息保护边界的。**
- tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），那也不是空消息，udp协议会帮你封装上消息头
- negal优化算法：会将数据量小的，且时间间隔较短的数据一次性发送给对方（tcp优化算法，导致粘包的原因）



 